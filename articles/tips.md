# Секреты и хитрости

В этой статье собраны советы по написанию быстрого и компактного кода. Некоторые советы специфичны для фрибейсика, некоторые для всех языков программирования, некоторые для операционной системы Windows.


## Деление чисел с плавающей запятой

Если у вас числа с плавающей запятой (Single или Double), то для повышения точности вычислений лучше не делить на `N`, а умножать на десятичную дробь из `(1 / N)`.

Например, вместо деления на 2,0 следует умножать на 0,5; вместо деления на 3,0 — умножать 0,3(3), и так далее:

```FreeBASIC
' У этой операции относительная погрешность будет больше
Dim Result As Double = 1.5 / 2.0

' Так будет точнее
Dim Result As Double = 1.5 * 0.5
```

## Объявление переменных вместе с инициализирующим значением

В старом стиле бейсика приходилось сначала объявлять переменную, а потом присваивать ей значение:

```FreeBASIC
Dim Width As Integer
Width = 640

Dim Height As Integer
Height = 480
```

В новом стиле переменные можно объявлять вместе с инициализирующим значением:

```FreeBASIC
Dim Width As Integer = 640

Dim Height As Integer = 480
```

Используйте объявления переменных в новом стиле, это работает быстрее. В старом стиле получается, что сначала переменные будут инициализированы, а потом им присваивается значение.

## Прекращение инициализации переменных по умолчанию

При объявлении новой переменной ей сразу же присваивается значение по умолчанию, если мы не сделали это сами:

* целочисленным переменным присваивается значение 0;
* логические переменные получают значение `False`;
* строки фиксированной длины типа `ZString` и `WString` заполняются нулевыми символами на всю их длину;
* все элементы массива обнуляются.

Если нам не требуется инициализация переменных, для этого переменной нужно присвоить специальное значение `Any`:

```FreeBASIC
' Этой переменной значение по умолчанию не будет присвоено
' Сейчас в ней находится так называемый «мусор»
Dim Count As Integer = Any
```

В случае со строками необходимо поставить нулевой символ самостоятельно:

```FreeBASIC
' Память под строку выделена
Dim Value As WString * (MAX_BUFFER_LENGTH + 1) = Any

' Не забываем установить нулевой символ:
Value[0] = 0
```

## Объявление переменных ближе к месту где они используются

Старые компиляторы бейсика вынуждали пользователей объявлять все переменные в верхней части программы:

```BASIC
Dim A, B, C, Width, Height
```

Сейчас это уже неактуально. FreeBASIC не требует, чтобы все переменные обязательно были объявлены в самом верху функции. Стремитесь объявлять переменные как можно ближе к их первому использованию:

```FreeBASIC
Dim Age As Integer = 80
SetAge(Value)

Dim FirstName As String = "John Doe"
SetName(FirstName)
```

Если переменная используется только внутри блока, то её следует объявлять внутри блока:

```FreeBASIC
If Condition Then
	Dim Age As Integer = 80
	SetAge(Value)
End If
```

Это же относится к циклам `For`, счётчик цикла можно сразу указать в заголовке:

```FreeBASIC
For i As Integer = 0 To Length - 1
	Foo(i)
Next
```

Компилятор подсчитывает общее количество переменных в функции и выделяет под них память на стеке. Если какая‐то переменная существует в локальном блоке, то оптимизирующий компилятор может переиспользовать это место для других переменных, снижая нагрузку на память:

```FreeBASIC
Scope
	Dim Age As Integer = 80
	
	Print Hex(@Age)
	' Выведет 65FE00
End Scope

Scope
	' Переменная Length может занимать ту же ячейку памяти
	' что и переменная Age объявленная в предыдущем блоке
	' тем самым снижается нагрузка на память
	Dim Length As Integer = 512
	
	' При компиляции с оптимизацией выведет тот же адрес
	' что у переменной Age — 65FE00
	Print Hex(@Length)
End Scope
```

## Массивы без инициализации дескриптора массива

Массив во фрибейсике — это встроенный объект (дескриптор массива), в котором хранятся указатель на данные, количество измерений и размер каждого измерения. При объявлении массива фрибейсик автоматически создаёт дескриптор массива и инициализирует его поля. Это необходимо для контроля за границами и передачи массива в подпрограммы.

Однако если массив объявлен внутри структуры или как Shared‐переменная, то фрибейсик будет контролировать границы массива на этапе компиляции без создания дескриптора массива.

Воспользуемся этой особенностью и объявим структуру, содержащую в себе массив фиксированной длины:

```FreeBASIC
Const CAPACITY = 512

Type IntegerVector
	Buffer(CAPACITY - 1) As Integer
End Type
```

Теперь компилятор знает размер массива, и мы можем использовать экземпляр структуры с массивом внутри:

```FreeBASIC
Dim Vector As IntegerVector = Any

For i As Integer = 0 To CAPACITY - 1
	Vector.Buffer(i) = i
Next
```

## Проверка строк на пустоту

Если нужно проверить не пуста ли строка, то следует использовать функцию `Len`:

```FreeBASIC
If Len(s) Then
	' строка не пуста
End If
```

Сравнение строки с литеральной константой `""` работает медленнее, потому что требует сравнения символьных данных:

```FreeBASIC
' Этот код работает медленнее
If s = "" Then
	' строка пуста
End If
```

## Быстрая очистка (обнуление) строки

Для этого достаточно присвоить 0 первому символу в строке, то есть символу под индексом 0:

```FreeBASIC
Dim Value As WString * (MAX_BUFFER_LENGTH + 1) = Any

Value[0] = 0
```

## Получение символа в строке

Новички нередко используют функцию `Mid` для получения единственного символа в строке, однако есть способ проще.

Строка — это массив символов, следовательно, к ней можно применять индексирование по указателю:

```FreeBASIC
' Строка длиной в 99 символов (+1 на нулевой)
Dim s As WString * (99 + 1) = Any

' Получение пятого символа в строке
Dim charCode As Integer = s[4]
```

## Посимвольный обход строки

Предыдущий подход можно применять для посимвольного обхода строки в цикле. Проверяя текущий символ, цикл остановится как только встретится нулевой, обозначающий конец строки. Таким образом вычислять длину строки заранее не нужно:

```FreeBASIC
Dim Value As WString * (MAX_BUFFER_LENGTH + 1) = Any

Dim i As Integer

Do While Value[i] <> 0
	' Что‐то сделать с символом
	' Например, вывести на консоль
	Print Value[i]
	
	' Сдвигаем индекс на следующий символ
	i += 1
Loop
```

Если заранее известно, что строки будут ненулевой длины, то условие выхода из цикла `While s[i] <> 0` можно поставить после `Loop`.

## Выравнивание структур

В объявлении структур старайся располагать поля по убыванию их размера. Особенно нужно уделить внимание группировке вместе переменных, чей размер меньше текущей архитектуры: Byte, Short, Long, Boolean, их массивы и структуры с ними.

Например, обращение к переменной с типом Integer по выровненному адресу занимает всего один такт процессора, а если переменная не выровнена, то два такта на архитектуре i386. На некоторых архитектурах читать по невыровненному адресу вообще нельзя. Так происходит потому, что невыровненная переменная располагается в нескольких ячейках памяти: часть в одной и часть в следующей.

Такой код работает медленно:

```FreeBASIC
Type Foo
	Field1 As Boolean
	Field2 As Integer
End Type
```

Такой код работает быстро:

```FreeBASIC
Type Bar
	Field2 As Integer
	Field1 As Boolean
End Type
```
