# Признаки ужасно оформленного кода

Основания, по которым твой исходный код следует отнести в категорию низкого качества.

## Отсутствуют отступы

Первое, что бросается в глаза в некачественном коде — это отсутствие выделения логических блоков отступами:

```FreeBASIC
If a = 3 Then
b = 4
Else
d = 5
End If
```

Выделяй логические блоки отступами:

```FreeBASIC
If a = 3 Then
	b = 4
Else
	d = 5
End If
```


## Отсутствует форматирование

Не хватает пробелов в математических выражениях вроде:

```FreeBASIC
a=1+2/3-4
```

Иногда забывают пробелы между параметрами функций:

```FreeBASIC
result=SomeFunction(a,b,c)
```

Между операторами следует расставлять пробелы, поэтому правильный код выглядит так:

```FreeBASIC
a = 1 + 2 / 3 - 4
```

Расставляй пробелы после запятой в параметрах функций:

```FreeBASIC
result = SomeFunction(a, b, c)
```


## Отсутствуют вертикальные отступы

Когда функции и код прилеплены друг к другу подряд, это выглядит ужасно:

```FreeBASIC
Function Foo()As Integer
	' какой‐то код
End Function
Sub Bar()
	' какой‐то код
End Sub
Dim result As Integr
result = Foo()
```

Разделяй функции и код пустыми строками:

```FreeBASIC
Function Foo()As Integer
	' какой‐то код
End Function

Sub Bar()
	' какой‐то код
End Sub

Dim result As Integr
result = Foo()
```


## Псевдографика и ASCII‐арт

Часто для разделения функций и блоков кода используют псевдографику из звёздочек, символов комментария, знаков равенства:

```FreeBASIC
'====================================================================
' Процедура Foo
'====================================================================
Sub Foo()
	' какой‐то код
End Sub

'********************************************************************
' Процедура Bar
'********************************************************************
Sub Bar()
	' какой‐то код
End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Function Baz()As Integer
	' какой‐то код
End Function
```

Правило здесь только одно: не используйте псевдографику в коде.


## Дублирование окончания функций

Иногда после окончания функции дописывают её имя:

```FreeBASIC
Sub Foo()
	' какой‐то код
End Sub ' End of Foo
```

Не дублируйте окончания функций.


## Транслитерация

Часто в идентификаторах используют транслитерацию:

```FreeBASIC
Dim As Integer kolichestvo, razmer, massiv, matrica
ssylka, vikup, tovar, yslyga или checkTovaraNaNalichieTseni
```

Иногда транслитерация просачивается в строковые литералы:

```FreeBASIC
Print "vvedite chislo"
```

Вместо транслитерации следует использовать английские слова:

```FreeBASIC
Dim As Integer Count, Length, Vector, Matrix
Print "Please input number"
```

Строковые литералы можно сразу писать на русском языке:

```FreeBASIC
Print "Введите число"
```


## Несоблюдение регистра имени

FreeBASIC не различает регистр символов в идентификаторах и ключевых словах (`function` и `FUNCtion` — одно и то же). Некоторые позволяют себе смешивать регистры:

```FreeBASIC
Dim Vector() As Integer
' Далее в коде:
vector(0) = 265

' Декларация функции
Declare Function Foo()
' Далее в коде:
result = foo()
```

Пишите идентификаторы так, как они объявляются в коде впервые:

```FreeBASIC
Dim Vector() As Integer
' Далее в коде:
Vector(0) = 265

' Декларация функции
Declare Function Foo()
' Далее в коде:
result = Foo()
```


## Смешивание разных стилей именования

Когда вы пишете собственный код, вы должны определить, в каком стиле будут все ваши идентификаторы:

* capitalized case
* camelCase
* snake_case

При смешивании разный стилей кодовая база выглядит несогласованно:

```FreeBASIC
Declare Sub swap_value
Declare Function ShowInfo() As Integer
Declare Sub setInfo()
```

Придерживайтесь единого стиля идентификаторов:

```FreeBASIC
Declare Sub swap_value
Declare Function show_info() As Integer
Declare Sub set_info()
```


## Код между функций

Код в котором тела функций перемежаются голым кодом, выглядит ужасно:

```FreeBASIC
Dim result As Integr

Function Foo()As Integer
	' какой‐то код
End Function

result = Foo()

Sub Bar()
	' какой‐то код
End Sub
```

Располагайте функции и код отдельно:

```FreeBASIC
Function Foo()As Integer
	' какой‐то код
End Function

Sub Bar()
	' какой‐то код
End Sub

Dim result As Integr
result = Foo()
```

## Смешивание локальных и глобальных переменных

Код в котором объявление глобальных переменных перемежается локальными:

```FreeBASIC
Dim As integer i, event
Dim Shared As HWND hwnd
Dim As String setting
```

Глобальные переменные следует отделять:

```FreeBASIC
Dim Shared As HWND hwnd

Dim As integer i, event
Dim As String setting
```


## Несколько инструкций на одной строке

Часто встречаются однострочники:

```FreeBASIC
a = 1: b = 2: c = 3
```

Используйте принцип «одна строка = одна инструкция»:

```FreeBASIC
a = 1
b = 2
c = 3
```


## Множественные Else If вместо одного Select

Иногда в коде проверяют одну и ту же переменную несколько раз:

```FreeBASIC
If a = 1 Then
	Foo()
Else If a = 2 Then
	Bar()
Else If a = 3 Then
	Baz()
End If
```

Используйте выражение `Select`:

```FreeBASIC
Select Case a
	Case 1
		Foo()
	Case 2
		Bar()
	Case 3
		Baz()
End Select
```


## Смешивание однострочных и многострочных If

В одном коде:

```FreeBASIC
If a = b Then Foo() Else Bar()

If c = d Then
	Foo1()
	Foo2()
Else
	Bar1()
	Bar2()
End If
```

Используйте только многострочный вариант, даже если тело условия состоит из одного выражения:

```FreeBASIC
If a = b Then
	Foo()
Else
	Bar()
End If
```


## Переопределение переменных

Использование одной и той же переменной для нескольких действий в коде. Например, хранение в одной и той же переменной квадратного корня и периметра:

```FreeBASIC
Dim result As Double
result = Sqrt(...)
result = Perimeter(...)
```

Вместо этого заведите отдельные переменные для квадратного корня и периметра:

```FreeBASIC
Dim root As Double = Sqrt(...)
Dim perimeter As Double = Perimeter(...)
```

Иногда эта ошибка встречается не настолько явно. Например, в одной и той же переменной хранятся коды ошибок разных функций:

```FreeBASIC
Dim dwError As DWORD

' Вызываем функцию
RegisterClassEx(...)
' Получаем код ошибки
dwError = GetLastError()

' Вызываем другую функцию
CreateWindowEx(...)
' Храним код ошибки в той же переменной
dwError = GetLastError()
```

Заводите отдельные переменные для кодов ошибок разных функций:

```FreeBASIC
' Вызываем функцию
RegisterClassEx(...)
' Получаем код ошибки
Dim dwErrorRegister As DWORD = GetLastError()

' Вызываем другую функцию
CreateWindowEx(...)
' Храним код ошибки в той же переменной
Dim dwErrorCreate As DWORD = GetLastError()
```


## Sleep в конце программы

Часто для остановки программы используют Sleep(), чтобы не потерять консольный вывод.

На самом же деле серьёзные консольные утилиты звпускают из консоли или в пакетном режиме, и Sleep в конце программы сбивает с толку, это выглядит так, будто программа зависла.

Не используйте Sleep() чтобы не потерять консольный вывод программы.


## Закомментированный код

Почему код в комментариях это плохо:

* отвлекает внимание от чтения нормального кода;
* устаревший код, не содержит актуальных инструкций;
* вы закомментировали и забыли, а другим не хватит храбрости его удалить, вдруг это что‐то ценное;
* кодовая база превращается в сборник советов, рекомендаций, 87 хитростей, лучших практик, «как надо делать», «список и назначение всех флагов которые может принимать функция» — это превращает проект в выдачу поисковика, для этого есть внешние ресурсы типа MSDN и StackOverFlow;
* для хранения кода на случай отмены следует использовать систему контроля версий.


## Игнорирование области видимости

* глобальные переменные
* объявление всех переменных в начале функций


## Отсутствие модульности

Весь код в одном файле, нет разделения кодовой базы на модули.

## Другое

* названия функций и процедур с большим количеством сокращений и аббревиатур;
* волшебные числа (Magic Numbers);
* код не говорит сам за себя: ужасные имена переменных, неочевидные «param», «a», «b» (Таинственный код, Cryptic code);
* установка параметров подпрограмм в наборе глобальных переменных (накопить и запустить);
* однобуквенные имена переменных не для счётчиков цикла или каких‐нибудь X и Y;
* объявление переменных с большей областью видимости, чем это требуется;
